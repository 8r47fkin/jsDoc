<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<base href="../../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>A Tour of JavaScript</h1>
        <br>
        <p>
            This section presents a quick introduction, through code examples, to the JavaScript
            language. After this introductory chapter, we dive into JavaScript at the lowest level:
            Chapter 2 explains things like JavaScript comments, semicolons, and the Unicode
            character set. Chapter 3 starts to get more interesting: it explains JavaScript variables
            and the values you can assign to those variables.
        </p>
        <p>
            Here’s some sample code to illustrate the highlights of those two chapters:
            <code>
                // Anything following double slashes is an English-language comment.
                // Read the comments carefully: they explain the JavaScript code.
                // A variable is a symbolic name for a value.
                // Variables are declared with the let keyword:
                let x; // Declare a variable named x.
                // Values can be assigned to variables with an = sign
                x = 0; // Now the variable x has the value 0
                x // => 0: A variable evaluates to its value.
                // JavaScript supports several types of values
                x = 1; // Numbers.
                x = 0.01; // Numbers can be integers or reals.
                x = "hello world"; // Strings of text in quotation marks.
                x = 'JavaScript'; // Single quote marks also delimit strings.
                x = true; // A Boolean value.
                x = false; // The other Boolean value.
                x = null; // Null is a special value that means "no value."
                x = undefined; // Undefined is another special value like null.
            </code>
            Two other very important types that JavaScript programs can manipulate are objects
            and arrays. These are the subjects of Chapters 6 and 7, but they are so important that
            you’ll see them many times before you reach those chapters:
            <code>
                // JavaScript's most important datatype is the object.
                // An object is a collection of name/value pairs, or a string to value map.
                let book = { // Objects are enclosed in curly braces.
                topic: "JavaScript", // The property "topic" has value "JavaScript."
                edition: 7 // The property "edition" has value 7
                }; // The curly brace marks the end of the object.

                // Access the properties of an object with . or []:
                book.topic // => "JavaScript"
                book["edition"] // => 7: another way to access property values.
                book.author = "Flanagan"; // Create new properties by assignment.
                book.contents = {}; // {} is an empty object with no properties.

                // Conditionally access properties with ?. (ES2020):
                book.contents?.ch01?.sect1 // => undefined: book.contents has no ch01 property.

                // JavaScript also supports arrays (numerically indexed lists) of values:
                let primes = [2, 3, 5, 7]; // An array of 4 values, delimited with [ and ].
                primes[0] // => 2: the first element (index 0) of the array.
                primes.length // => 4: how many elements in the array.
                primes[primes.length-1] // => 7: the last element of the array.
                primes[4] = 9; // Add a new element by assignment.
                primes[4] = 11; // Or alter an existing element by assignment.
                let empty = []; // [] is an empty array with no elements.
                empty.length // => 0

                // Arrays and objects can hold other arrays and objects:
                let points = [ // An array with 2 elements.
                {x: 0, y: 0}, // Each element is an object.
                {x: 1, y: 1}
                ];
                let data = { // An object with 2 properties
                trial1: [[1,2], [3,4]], // The value of each property is an array.
                trial2: [[2,3], [4,5]] // The elements of the arrays are arrays.
                };            
            </code>
            The syntax illustrated here for listing array elements within square braces or mapping
            object property names to property values inside curly braces is known as an initializer
            expression, and it is just one of the topics of Chapter 4. An expression is a phrase of
            JavaScript that can be evaluated to produce a value. For example, the use of . and []
            to refer to the value of an object property or array element is an expression.
        </p>
        <p>
            One of the most common ways to form expressions in JavaScript is to use operators:
            <code>
                // Operators act on values (the operands) to produce a new value.
                // Arithmetic operators are some of the simplest:
                3 + 2 // => 5: addition
                3 - 2 // => 1: subtraction
                3 * 2 // => 6: multiplication
                3 / 2 // => 1.5: division
                points[1].x - points[0].x // => 1: more complicated operands also work
                "3" + "2" // => "32": + adds numbers, concatenates strings

                // JavaScript defines some shorthand arithmetic operators
                let count = 0; // Define a variable
                count++; // Increment the variable
                count--; // Decrement the variable
                count += 2; // Add 2: same as count = count + 2;
                count *= 3; // Multiply by 3: same as count = count * 3;
                count // => 6: variable names are expressions, too.

                // Equality and relational operators test whether two values are equal,
                // unequal, less than, greater than, and so on. They evaluate to true or false.
                let x = 2, y = 3; // These = signs are assignment, not equality tests
                x === y // => false: equality
                x !== y // => true: inequality
                x < y // => true: less-than
                x <= y // => true: less-than or equal
                x > y // => false: greater-than
                x >= y // => false: greater-than or equal
                "two" === "three" // => false: the two strings are different
                "two" > "three" // => true: "tw" is alphabetically greater than "th"
                false === (x > y) // => true: false is equal to false

                // Logical operators combine or invert boolean values
                (x === 2) && (y === 3) // => true: both comparisons are true. && is AND
                (x > 3) || (y < 3) // => false: neither comparison is true. || is OR
                !(x === y) // => true: ! inverts a boolean value
            </code>
        </p>
        <p>
            If JavaScript expressions are like phrases, then JavaScript statements are like full sentences. 
            Statements are the topic of Chapter 5. Roughly, an expression is something
            that computes a value but doesn’t do anything: it doesn’t alter the program state in any
            way. Statements, on the other hand, don’t have a value, but they do alter the state.
            You’ve seen variable declarations and assignment statements above. The other broad
            category of statement is control structures, such as conditionals and loops. You’ll see
            examples below, after we cover functions.
        </p>
        <p>
            A function is a named and parameterized block of JavaScript code that you define
            once, and can then invoke over and over again. Functions aren’t covered formally
            until Chapter 8, but like objects and arrays, you’ll see them many times before you get
            to that chapter. Here are some simple examples:
        </p>
        <code>
            // Functions are parameterized blocks of JavaScript code that we can invoke.
            function plus1(x) { // Define a function named "plus1" with parameter "x"
            return x + 1; // Return a value one larger than the value passed in
            } // Functions are enclosed in curly braces

            plus1(y) // => 4: y is 3, so this invocation returns 3+1

            let square = function(x) { // Functions are values and can be assigned to vars
            return x * x; // Compute the function's value
            }; // Semicolon marks the end of the assignment.
            square(plus1(y)) // => 16: invoke two functions in one expression
        </code>
        <p>
            In ES6 and later, there is a shorthand syntax for defining functions. This concise syntax 
            uses => to separate the argument list from the function body, so functions defined
            this way are known as arrow functions. Arrow functions are most commonly used
            when you want to pass an unnamed function as an argument to another function.
            The preceding code looks like this when rewritten to use arrow functions:
            <code>
                const plus1 = x => x + 1; // The input x maps to the output x + 1
                const square = x => x * x; // The input x maps to the output x * x
                plus1(y) // => 4: function invocation is the same
                square(plus1(y)) // => 16
            </code>
            When we use functions with objects, we get methods:
        </p>
        <code>
            // When functions are assigned to the properties of an object, we call
            // them "methods." All JavaScript objects (including arrays) have methods:
            let a = []; // Create an empty array
            a.push(1,2,3); // The push() method adds elements to an array
            a.reverse(); // Another method: reverse the order of elements

            // We can define our own methods, too. The "this" keyword refers to the object
            // on which the method is defined: in this case, the points array from earlier.
            points.dist = function() { // Define a method to compute distance between points
            let p1 = this[0]; // First element of array we're invoked on
            let p2 = this[1]; // Second element of the "this" object
            let a = p2.x-p1.x; // Difference in x coordinates
            let b = p2.y-p1.y; // Difference in y coordinates
            return Math.sqrt(a*a + // The Pythagorean theorem
            b*b); // Math.sqrt() computes the square root
            };
            points.dist() // => Math.sqrt(2): distance between our 2 points
        </code>
        <p>
            Now, as promised, here are some functions whose bodies demonstrate common JavaScript 
            control structure statements:
            <code>
                // JavaScript statements include conditionals and loops using the syntax
                // of C, C++, Java, and other languages.
                function abs(x) { // A function to compute the absolute value.
                if (x >= 0) { // The if statement...
                return x; // executes this code if the comparison is true.
                } // This is the end of the if clause.
                else { // The optional else clause executes its code if
                return -x; // the comparison is false.
                } // Curly braces optional when 1 statement per clause.
                } // Note return statements nested inside if/else.
                abs(-10) === abs(10) // => true
                function sum(array) { // Compute the sum of the elements of an array
                let sum = 0; // Start with an initial sum of 0.
                for(let x of array) { // Loop over array, assigning each element to x.
                sum += x; // Add the element value to the sum.
                } // This is the end of the loop.
                return sum; // Return the sum.
                }
                sum(primes) // => 28: sum of the first 5 primes 2+3+5+7+11
                function factorial(n) { // A function to compute factorials
                let product = 1; // Start with a product of 1
                while(n > 1) { // Repeat statements in {} while expr in () is true
                product *= n; // Shortcut for product = product * n;
                n--; // Shortcut for n = n - 1
                } // End of loop

                return product; // Return the product
                }
                factorial(4) // => 24: 1*4*3*2
                function factorial2(n) { // Another version using a different loop
                let i, product = 1; // Start with 1
                for(i=2; i <= n; i++) // Automatically increment i from 2 up to n
                product *= i; // Do this each time. {} not needed for 1-line loops
                return product; // Return the factorial
                }
                factorial2(5) // => 120: 1*2*3*4*5
            </code>
        </p>
        <p>
            JavaScript supports an object-oriented programming style, but it is significantly different 
            than “classical” object-oriented programming languages. Chapter 9 covers
            object-oriented programming in JavaScript in detail, with lots of examples. Here is a
            very simple example that demonstrates how to define a JavaScript class to represent
            2D geometric points. Objects that are instances of this class have a single method,
            named distance(), that computes the distance of the point from the origin:
        </p>
        <code>
            class Point { // By convention, class names are capitalized.
                constructor(x, y) { // Constructor function to initialize new instances.
                this.x = x; // This keyword is the new object being initialized.
                this.y = y; // Store function arguments as object properties.
                } // No return is necessary in constructor functions.
                distance() { // Method to compute distance from origin to point.
                return Math.sqrt( // Return the square root of x² + y².
                this.x * this.x + // this refers to the Point object on which
                this.y * this.y // the distance method is invoked.
                );
                }
               }
               // Use the Point() constructor function with "new" to create Point objects
               let p = new Point(1, 1); // The geometric point (1,1).
               // Now use a method of the Point object p
               p.distance() // => Math.SQRT2
        </code>
        <p>
            This introductory tour of JavaScript’s fundamental syntax and capabilities ends here,
            but the book continues with self-contained chapters that cover additional features of
            the language:
        </p>
        <p>
            Chapter 10, Modules <br>
            Shows how JavaScript code in one file or script can use JavaScript functions and
            classes defined in other files or scripts.
        </p>
        <p>
            Chapter 11, The JavaScript Standard Library <br>
            Covers the built-in functions and classes that are available to all JavaScript programs. 
            This includes important data stuctures like maps and sets, a regular expression class for 
            textual pattern matching, functions for serializing JavaScript
            data structures, and much more.
        </p>
        <p>
            Chapter 12, Iterators and Generators <br>
            Explains how the for/of loop works and how you can make your own classes
            iterable with for/of. It also covers generator functions and the yield statement.
        </p>
        <p>
            Chapter 13, Asynchronous JavaScript <br>
            This chapter is an in-depth exploration of asynchronous programming in Java‐
            Script, covering callbacks and events, Promise-based APIs, and the async and
            await keywords. Although the core JavaScript language is not asynchronous,
            asynchronous APIs are the default in both web browsers and Node, and this
            chapter explains the techniques for working with those APIs
        </p>
        <p>
            Chapter 14, Metaprogramming <br>
            Introduces a number of advanced features of JavaScript that may be of interest to
            programmers writing libraries of code for other JavaScript programmers to use.
        </p>
        <p>
            Chapter 15, JavaScript in Web Browsers <br>
            Introduces the web browser host environment, explains how web browsers exe‐
            cute JavaScript code, and covers the most important of the many APIs defined by
            web browsers. This is by far the longest chapter in the book.
        </p>
        <p>
            Chapter 16, Server-Side JavaScript with Node <br>
            Introduces the Node host environment, covering the fundamental programming
            model and the data structures and APIs that are most important to understand.
        </p>
        <p>
            Chapter 17, JavaScript Tools and Extensions <br>
            Covers tools and language extensions that are worth knowing about because they
            are widely used and may make you a more productive programmer.
        </p>

		<p>
			<br>
            <ul>
                <li>[link:#api/en/js/introduction/example Example Character Frequency Histograms]</li>
                <li>[link:#api/en/js/introduction/summary Summary]</li>
            </ul>   
		</p>

		<h2>Next Steps</h2>
		<p>
			Time for [link:#api/en/js/lexical-structure/index Lexical Structure].
		</p>
	</body>
</html>
